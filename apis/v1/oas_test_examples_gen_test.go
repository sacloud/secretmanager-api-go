// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCreateSecret_EncodeDecode(t *testing.T) {
	var typ CreateSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateVault_EncodeDecode(t *testing.T) {
	var typ CreateVault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateVault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDateTime_EncodeDecode(t *testing.T) {
	var typ DateTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DateTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSecret_EncodeDecode(t *testing.T) {
	var typ DeleteSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedSecretList_EncodeDecode(t *testing.T) {
	var typ PaginatedSecretList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedSecretList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedVaultList_EncodeDecode(t *testing.T) {
	var typ PaginatedVaultList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedVaultList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSecret_EncodeDecode(t *testing.T) {
	var typ Secret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Secret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnveil_EncodeDecode(t *testing.T) {
	var typ Unveil
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Unveil
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVault_EncodeDecode(t *testing.T) {
	var typ Vault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Vault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateSecret_EncodeDecode(t *testing.T) {
	var typ WrappedCreateSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateVault_EncodeDecode(t *testing.T) {
	var typ WrappedCreateVault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateVault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedDeleteSecret_EncodeDecode(t *testing.T) {
	var typ WrappedDeleteSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedDeleteSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedSecret_EncodeDecode(t *testing.T) {
	var typ WrappedSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedUnveil_EncodeDecode(t *testing.T) {
	var typ WrappedUnveil
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedUnveil
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedVault_EncodeDecode(t *testing.T) {
	var typ WrappedVault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedVault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
